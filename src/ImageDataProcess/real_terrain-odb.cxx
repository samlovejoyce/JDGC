// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "real_terrain-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy


#include <odb/mysql/traits.hxx>
#include <odb/mysql/database.hxx>
#include <odb/mysql/transaction.hxx>
#include <odb/mysql/connection.hxx>
#include <odb/mysql/statement.hxx>
#include <odb/mysql/statement-cache.hxx>
#include <odb/mysql/no-id-object-statements.hxx>
#include <odb/mysql/container-statements.hxx>
#include <odb/mysql/exceptions.hxx>
#include <odb/mysql/no-id-object-result.hxx>
#include <odb/mysql/enum.hxx>

namespace odb
{
  // real_terrain
  //

  bool access::object_traits_impl< ::real_terrain, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // xblocksno
    //
    t[0UL] = 0;

    // yblocksno
    //
    t[1UL] = 0;

    // xblocksize
    //
    t[2UL] = 0;

    // yblocksize
    //
    t[3UL] = 0;

    // zdata
    //
    if (t[4UL])
    {
      i.zdata_value.capacity (i.zdata_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::real_terrain, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // xblocksno
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.xblocksno_value;
    b[n].is_null = &i.xblocksno_null;
    n++;

    // yblocksno
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.yblocksno_value;
    b[n].is_null = &i.yblocksno_null;
    n++;

    // xblocksize
    //
    b[n].buffer_type = MYSQL_TYPE_SHORT;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.xblocksize_value;
    b[n].is_null = &i.xblocksize_null;
    n++;

    // yblocksize
    //
    b[n].buffer_type = MYSQL_TYPE_SHORT;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.yblocksize_value;
    b[n].is_null = &i.yblocksize_null;
    n++;

    // zdata
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.zdata_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.zdata_value.capacity ());
    b[n].length = &i.zdata_size;
    b[n].is_null = &i.zdata_null;
    n++;
  }

  bool access::object_traits_impl< ::real_terrain, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // xblocksno
    //
    {
      unsigned int const& v =
        o.xblocksno;

      bool is_null (false);
      mysql::value_traits<
          unsigned int,
          mysql::id_ulong >::set_image (
        i.xblocksno_value, is_null, v);
      i.xblocksno_null = is_null;
    }

    // yblocksno
    //
    {
      unsigned int const& v =
        o.yblocksno;

      bool is_null (false);
      mysql::value_traits<
          unsigned int,
          mysql::id_ulong >::set_image (
        i.yblocksno_value, is_null, v);
      i.yblocksno_null = is_null;
    }

    // xblocksize
    //
    {
      short unsigned int const& v =
        o.xblocksize;

      bool is_null (false);
      mysql::value_traits<
          short unsigned int,
          mysql::id_ushort >::set_image (
        i.xblocksize_value, is_null, v);
      i.xblocksize_null = is_null;
    }

    // yblocksize
    //
    {
      short unsigned int const& v =
        o.yblocksize;

      bool is_null (false);
      mysql::value_traits<
          short unsigned int,
          mysql::id_ushort >::set_image (
        i.yblocksize_value, is_null, v);
      i.yblocksize_null = is_null;
    }

    // zdata
    //
    {
      ::buffer const& v =
        o.zdata;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.zdata_value.capacity ());
      mysql::value_traits<
          ::buffer,
          mysql::id_blob >::set_image (
        i.zdata_value,
        size,
        is_null,
        v);
      i.zdata_null = is_null;
      i.zdata_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.zdata_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::real_terrain, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // xblocksno
    //
    {
      unsigned int& v =
        o.xblocksno;

      mysql::value_traits<
          unsigned int,
          mysql::id_ulong >::set_value (
        v,
        i.xblocksno_value,
        i.xblocksno_null);
    }

    // yblocksno
    //
    {
      unsigned int& v =
        o.yblocksno;

      mysql::value_traits<
          unsigned int,
          mysql::id_ulong >::set_value (
        v,
        i.yblocksno_value,
        i.yblocksno_null);
    }

    // xblocksize
    //
    {
      short unsigned int& v =
        o.xblocksize;

      mysql::value_traits<
          short unsigned int,
          mysql::id_ushort >::set_value (
        v,
        i.xblocksize_value,
        i.xblocksize_null);
    }

    // yblocksize
    //
    {
      short unsigned int& v =
        o.yblocksize;

      mysql::value_traits<
          short unsigned int,
          mysql::id_ushort >::set_value (
        v,
        i.yblocksize_value,
        i.yblocksize_null);
    }

    // zdata
    //
    {
      ::buffer& v =
        o.zdata;

      mysql::value_traits<
          ::buffer,
          mysql::id_blob >::set_value (
        v,
        i.zdata_value,
        i.zdata_size,
        i.zdata_null);
    }
  }

  const char access::object_traits_impl< ::real_terrain, id_mysql >::persist_statement[] =
  "INSERT INTO `real_terrain` "
  "(`xblocksno`, "
  "`yblocksno`, "
  "`xblocksize`, "
  "`yblocksize`, "
  "`zdata`) "
  "VALUES "
  "(?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::real_terrain, id_mysql >::query_statement[] =
  "SELECT "
  "`real_terrain`.`xblocksno`, "
  "`real_terrain`.`yblocksno`, "
  "`real_terrain`.`xblocksize`, "
  "`real_terrain`.`yblocksize`, "
  "`real_terrain`.`zdata` "
  "FROM `real_terrain`";

  const char access::object_traits_impl< ::real_terrain, id_mysql >::erase_query_statement[] =
  "DELETE FROM `real_terrain`";

  const char access::object_traits_impl< ::real_terrain, id_mysql >::table_name[] =
  "`real_terrain`";

  void access::object_traits_impl< ::real_terrain, id_mysql >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  result< access::object_traits_impl< ::real_terrain, id_mysql >::object_type >
  access::object_traits_impl< ::real_terrain, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::no_id_object_result_impl<object_type> > r (
      new (shared) mysql::no_id_object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::real_terrain, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }
}

#include <odb/post.hxx>
